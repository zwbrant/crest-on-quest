// <auto-generated/>

// Crest Water System
// Copyright Â© 2024 Wave Harmonic. All rights reserved.

namespace WaveHarmonic.Crest
{
    partial class AnimatedWavesLod
    {
        /// <summary>
        /// How much waves are dampened in shallow water.
        /// </summary>
        public float AttenuationInShallows { get => _AttenuationInShallows; set => _AttenuationInShallows = value; }

        /// <summary>
        /// Collision layers to enable.
        /// </summary>
        /// <remarks>
        /// Some layers will have overhead with CPU, GPU and memory.
        /// </remarks>
        public CollisionLayers CollisionLayers { get => _CollisionLayers; set => _CollisionLayers = value; }

        /// <summary>
        /// Where to obtain water shape on CPU for physics / gameplay.
        /// </summary>
        public CollisionSource CollisionSource { get => _CollisionSource; internal set => _CollisionSource = value; }

        /// <summary>
        /// Maximum number of wave queries that can be performed when using GPU queries.
        /// </summary>
        public int MaximumQueryCount => _MaximumQueryCount;

        /// <summary>
        /// Any water deeper than this will receive full wave strength.
        /// </summary>
        /// <remarks>
        /// The lower the value, the less effective the depth cache will be at attenuating very large waves. Set to the maximum value (1,000) to disable.
        /// </remarks>
        public float ShallowsMaximumDepth { get => _ShallowsMaximumDepth; set => _ShallowsMaximumDepth = value; }

        /// <summary>
        /// Shifts wavelengths to maintain quality for higher resolutions.
        /// </summary>
        /// <remarks>
        /// Set this to 2 to improve wave quality. In some cases like flowing rivers, this can make a substantial difference to visual stability. We recommend doubling the Resolution on the WaterRenderer component to preserve detail after making this change.
        /// </remarks>
        public float WaveResolutionMultiplier { get => _WaveResolutionMultiplier; set => _WaveResolutionMultiplier = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class AnimatedWavesLodInput
    {
        /// <summary>
        /// When to render the input into the displacement data.
        /// </summary>
        public DisplacementPass DisplacementPass { get => _DisplacementPass; set => _DisplacementPass = value; }

        /// <summary>
        /// Whether to filter this input by wavelength.
        /// </summary>
        /// <remarks>
        /// If disabled, it will render to all LODs.
        /// </remarks>
        public bool FilterByWavelength { get => _FilterByWavelength; set => _FilterByWavelength = value; }

        /// <summary>
        /// Inform the system how much this input will displace the water surface horizontally.
        /// </summary>
        /// <remarks>
        /// This is used to set bounding box widths for the water chunks.
        /// </remarks>
        public float MaximumDisplacementHorizontal { get => _MaximumDisplacementHorizontal; set => _MaximumDisplacementHorizontal = value; }

        /// <summary>
        /// Inform the system how much this input will displace the water surface vertically.
        /// </summary>
        /// <remarks>
        /// This is used to set bounding box heights for the water chunks.
        /// </remarks>
        public float MaximumDisplacementVertical { get => _MaximumDisplacementVertical; set => _MaximumDisplacementVertical = value; }

        /// <summary>
        /// Which octave to render into.
        /// </summary>
        /// <remarks>
        /// For example, set this to 2 to render into the 2m-4m octave. These refer to the same octaves as the wave spectrum editor.
        /// </remarks>
        public float OctaveWavelength { get => _OctaveWavelength; set => _OctaveWavelength = value; }

        /// <summary>
        /// When to render the input into the displacement data.
        /// </summary>
        /// <remarks>
        /// If enabled, it renders into all LODs of the simulation after the combine step rather than before with filtering. Furthermore, it will also affect dynamic waves.
        /// </remarks>
        [System.Obsolete("Please use DisplacementPass instead.")]
        public bool RenderPostCombine { get => _RenderPostCombine; set => SetRenderPostCombine(_RenderPostCombine, _RenderPostCombine = value); }

        /// <summary>
        /// Use the bounding box of an attached renderer component to determine the maximum vertical displacement.
        /// </summary>
        public bool ReportRendererBounds { get => _ReportRendererBounds; set => _ReportRendererBounds = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class ClipLod
    {
        /// <summary>
        /// The default clipping behaviour.
        /// </summary>
        /// <remarks>
        /// Whether to clip nothing by default (and clip inputs remove patches of surface), or to clip everything by default (and clip inputs add patches of surface).
        /// </remarks>
        public DefaultClippingState DefaultClippingState { get => _DefaultClippingState; set => SetDefaultClippingState(_DefaultClippingState, _DefaultClippingState = value); }
    }
}

namespace WaveHarmonic.Crest
{
    partial class ClipLodInput
    {
        /// <summary>
        /// Removes clip surface data instead of adding it.
        /// </summary>
        public bool Inverted { get => _Inverted; set => _Inverted = value; }

        /// <summary>
        /// The primitive to render (signed distance) into the simulation.
        /// </summary>
        public LodInputPrimitive Primitive { get => _Primitive; set => _Primitive = value; }

        /// <summary>
        /// Prevents inputs from cancelling each other out when aligned vertically.
        /// </summary>
        /// <remarks>
        /// It is imperfect so custom logic might be needed for your use case.
        /// </remarks>
        public bool WaterHeightDistanceCulling { get => _WaterHeightDistanceCulling; set => _WaterHeightDistanceCulling = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class ColorLod
    {
        /// <summary>
        /// Color of the shoreline color.
        /// </summary>
        public UnityEngine.Color ShorelineColor { get => _ShorelineColor; set => SetShorelineColor(_ShorelineColor, _ShorelineColor = value); }

        /// <summary>
        /// Shoreline color falloff value.
        /// </summary>
        public float ShorelineColorFalloff { get => _ShorelineColorFalloff; set => _ShorelineColorFalloff = value; }

        /// <summary>
        /// The maximum distance of the shoreline color.
        /// </summary>
        /// <remarks>
        /// If using Depth, then it is maximum depth.
        /// </remarks>
        public float ShorelineColorMaximumDistance { get => _ShorelineColorMaximumDistance; set => _ShorelineColorMaximumDistance = value; }

        /// <summary>
        /// Source of the shoreline color.
        /// </summary>
        public ShorelineVolumeColorSource ShorelineColorSource { get => _ShorelineColorSource; set => _ShorelineColorSource = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class CustomTimeProvider
    {
        /// <summary>
        /// The delta time override value.
        /// </summary>
        public float DeltaTime { get => _DeltaTime; set => _DeltaTime = value; }

        /// <summary>
        /// Whether to override the water simulation time.
        /// </summary>
        /// <remarks>
        /// This in particular affects dynamic elements of the simulation like the foam simulation and the ripple simulation.
        /// </remarks>
        public bool OverrideDeltaTime { get => _OverrideDeltaTime; set => _OverrideDeltaTime = value; }

        /// <summary>
        /// Whether to override the water simulation time.
        /// </summary>
        public bool OverrideTime { get => _OverrideTime; set => _OverrideTime = value; }

        /// <summary>
        /// Freeze progression of time. Only works properly in Play mode.
        /// </summary>
        public bool Paused { get => _Paused; set => _Paused = value; }

        /// <summary>
        /// The time override value.
        /// </summary>
        public float TimeOverride { get => _Time; set => _Time = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class CutsceneTimeProvider
    {
        /// <summary>
        /// Assign this time provider to the water system when this component becomes active.
        /// </summary>
        public bool AssignToWaterComponentOnEnable { get => _AssignToWaterComponentOnEnable; set => _AssignToWaterComponentOnEnable = value; }

#if d_ModuleUnityDirector
        /// <summary>
        /// Playable Director to take time from.
        /// </summary>
        public UnityEngine.Playables.PlayableDirector PlayableDirector { get => _PlayableDirector; set => _PlayableDirector = value; }
#endif

        /// <summary>
        /// Restore the time provider that was previously assigned to water system when this component disables.
        /// </summary>
        public bool RestorePreviousTimeProviderOnDisable { get => _RestorePreviousTimeProviderOnDisable; set => _RestorePreviousTimeProviderOnDisable = value; }

        /// <summary>
        /// Time offset which will be added to the Timeline time.
        /// </summary>
        public float TimeOffset { get => _TimeOffset; set => _TimeOffset = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class DepthLod
    {
        /// <summary>
        /// Support signed distance field data generated from the depth probes.
        /// </summary>
        /// <remarks>
        /// Requires a two component texture format.
        /// </remarks>
        public bool EnableSignedDistanceFields { get => _EnableSignedDistanceFields; set => SetEnableSignedDistanceFields(_EnableSignedDistanceFields, _EnableSignedDistanceFields = value); }

        /// <summary>
        /// Whether to include the terrain height automatically.
        /// </summary>
        /// <remarks>
        /// This will not include terrain details, nor will it produce a signed-distance field. There may also be a slight deviation due to differences in height data and terrain mesh. In these cases, please use the DepthProbe.
        /// </remarks>
        public bool IncludeTerrainHeight { get => _IncludeTerrainHeight; set => _IncludeTerrainHeight = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class DepthLodInput
    {
        /// <summary>
        /// Whether to copy the signed distance field.
        /// </summary>
        public bool CopySignedDistanceField { get => _CopySignedDistanceField; set => _CopySignedDistanceField = value; }

        /// <summary>
        /// Whether the data is relative to the input height.
        /// </summary>
        /// <remarks>
        /// Useful for procedural placement.
        /// </remarks>
        public bool Relative { get => _Relative; set => _Relative = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class DepthProbe
    {
        /// <summary>
        /// How many additional Jump Flood rounds to use.
        /// </summary>
        /// <remarks>
        /// The standard number of rounds is log2(resolution). Additional rounds can reduce innaccuracies.
        /// </remarks>
        public int AdditionalJumpFloodRounds { get => _AdditionalJumpFloodRounds; set => SetDirty(_AdditionalJumpFloodRounds, _AdditionalJumpFloodRounds = value); }

        /// <summary>
        /// The far and near plane of the depth probe camera respectively, relative to the transform.
        /// </summary>
        /// <remarks>
        /// Depth is captured top-down and orthographically. The gizmo will visualize this range as the bottom box.
        /// </remarks>
        public UnityEngine.Vector2 CaptureRange { get => _CaptureRange; set => SetDirty(_CaptureRange, _CaptureRange = value); }

        /// <summary>
        /// Increase coverage by testing mesh back faces within the Fill Holes area.
        /// </summary>
        /// <remarks>
        /// Uses the back-faces to include meshes where the front-face is within the Fill Holes area and the back-face is within the capture area. An example would be an upright cylinder not over a hole but was not captured due to the top being clipped by the near plane.
        /// </remarks>
        public bool EnableBackFaceInclusion { get => _EnableBackFaceInclusion; set => SetDirty(_EnableBackFaceInclusion, _EnableBackFaceInclusion = value); }

        /// <summary>
        /// Fills holes left by the maximum of the capture range.
        /// </summary>
        /// <remarks>
        /// Setting the maximum capture range lower than the highest point of geometry can be useful for eliminating depth artifacts from overhangs, but the side effect is there will be a hole in the depth data where geometry is clipped by the near plane. This will only capture where the holes are to fill them in. This height is relative to the maximum capture range. Set to zero to skip.
        /// </remarks>
        public float FillHolesCaptureHeight { get => _FillHolesCaptureHeight; set => SetDirty(_FillHolesCaptureHeight, _FillHolesCaptureHeight = value); }

        /// <summary>
        /// Generate a signed distance field for the shoreline.
        /// </summary>
        public bool GenerateSignedDistanceField { get => _GenerateSignedDistanceField; set => SetDirty(_GenerateSignedDistanceField, _GenerateSignedDistanceField = value); }

        /// <summary>
        /// The layers to render into the probe.
        /// </summary>
        public UnityEngine.LayerMask Layers { get => _Layers; set => SetDirty(_Layers, _Layers = value); }

        /// <summary>
        /// Overrides global quality settings.
        /// </summary>
        public QualitySettingsOverride QualitySettingsOverride => _QualitySettingsOverride;

        /// <summary>
        /// Controls how the probe is refreshed in the Player.
        /// </summary>
        /// <remarks>
        /// Call Populate() if scripting.
        /// </remarks>
        public DepthProbeRefreshMode RefreshMode { get => _RefreshMode; set => _RefreshMode = value; }

        /// <summary>
        /// The resolution of the probe.
        /// </summary>
        /// <remarks>
        /// Lower will be more efficient.
        /// </remarks>
        public int Resolution { get => _Resolution; set => SetDirty(_Resolution, _Resolution = value); }

        /// <summary>
        /// Baked probe.
        /// </summary>
        /// <remarks>
        /// Can only bake in edit mode.
        /// </remarks>
        public UnityEngine.Texture2D SavedTexture { get => _SavedTexture; set => _SavedTexture = value; }

        /// <summary>
        /// Specifies the setup for this probe.
        /// </summary>
        public DepthProbeMode Type { get => _Type; set => _Type = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class DirectionalTextureLodInputData
    {
        /// <summary>
        /// Whether the texture supports negative values.
        /// </summary>
        public bool NegativeValues { get => _NegativeValues; set => _NegativeValues = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class DynamicWavesLod
    {
        /// <summary>
        /// How much waves are dampened in shallow water.
        /// </summary>
        public float AttenuationInShallows { get => _AttenuationInShallows; set => _AttenuationInShallows = value; }

        /// <summary>
        /// Settings for fine tuning this simulation.
        /// </summary>
        public DynamicWavesLodSettings Settings { get => GetSettings(); set => _Settings = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class DynamicWavesLodSettings
    {
        /// <summary>
        /// Stability control.
        /// </summary>
        /// <remarks>
        /// Lower values means more stable simulation, but may slow down some dynamic waves. This value should be set as large as possible until simulation instabilities/flickering begin to appear. Default is 0.7.
        /// </remarks>
        public float CourantNumber { get => _CourantNumber; set => _CourantNumber = value; }

        /// <summary>
        /// How much energy is dissipated each frame.
        /// </summary>
        /// <remarks>
        /// Helps simulation stability, but limits how far ripples will propagate. Set this as large as possible/acceptable. Default is 0.05.
        /// </remarks>
        public float Damping { get => _Damping; set => _Damping = value; }

        /// <summary>
        /// Clamp displacement to help prevent self-intersection in steep waves.
        /// </summary>
        /// <remarks>
        /// Zero means unclamped.
        /// </remarks>
        public float DisplaceClamp { get => _DisplaceClamp; set => _DisplaceClamp = value; }

        /// <summary>
        /// Multiplier for gravity.
        /// </summary>
        /// <remarks>
        /// More gravity means dynamic waves will travel faster. Higher values can be a source of instability.
        /// </remarks>
        public float GravityMultiplier { get => _GravityMultiplier; set => _GravityMultiplier = value; }

        /// <summary>
        /// Induce horizontal displacements to sharpen simulated waves.
        /// </summary>
        public float HorizontalDisplace { get => _HorizontalDisplace; set => _HorizontalDisplace = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class FloatingObject
    {
        /// <summary>
        /// Approximate hydrodynamics of 'surfing' down waves.
        /// </summary>
        public float AccelerateDownhill { get => _AccelerateDownhill; set => _AccelerateDownhill = value; }

        /// <summary>
        /// Angular drag when in water.
        /// </summary>
        /// <remarks>
        /// Additive to the angular drag declared on the rigid body.
        /// </remarks>
        public float AngularDrag { get => _AngularDrag; set => _AngularDrag = value; }

        /// <summary>
        /// Strength of buoyancy force.
        /// </summary>
        /// <remarks>
        /// For probes, roughly a mass to force ratio of 100 to 1 to keep the center of mass near the surface. For Align Normal, default value is for a default sphere with a default rigidbody.
        /// </remarks>
        public float BuoyancyForceStrength { get => _BuoyancyForceStrength; set => _BuoyancyForceStrength = value; }

        /// <summary>
        /// Strength of torque applied to match boat orientation to water normal.
        /// </summary>
        public float BuoyancyTorqueStrength { get => _BuoyancyTorqueStrength; set => _BuoyancyTorqueStrength = value; }

        /// <summary>
        /// Height offset from transform center to bottom of boat (if any).
        /// </summary>
        /// <remarks>
        /// Default value is for a default sphere. Having this value be an accurate measurement from center to bottom is not necessary.
        /// </remarks>
        public float CenterToBottomOffset { get => _CenterToBottomOffset; set => _CenterToBottomOffset = value; }

        /// <summary>
        /// Drag when in water.
        /// </summary>
        /// <remarks>
        /// Additive to the drag declared on the rigid body.
        /// </remarks>
        public UnityEngine.Vector3 Drag { get => _Drag; set => _Drag = value; }

        /// <summary>
        /// Vertical offset for where drag force should be applied.
        /// </summary>
        public float ForceHeightOffset { get => _ForceHeightOffset; set => _ForceHeightOffset = value; }

        /// <summary>
        /// Which water collision layer to target.
        /// </summary>
        public CollisionLayer Layer { get => _Layer; set => _Layer = value; }

        /// <summary>
        /// Clamps the buoyancy force to this value.
        /// </summary>
        /// <remarks>
        /// Useful for handling fully submerged objects.
        /// </remarks>
        public float MaximumBuoyancyForce { get => _MaximumBuoyancyForce; set => _MaximumBuoyancyForce = value; }

        /// <summary>
        /// The model to use for buoyancy.
        /// </summary>
        /// <remarks>
        /// Align Normal is simple and only uses a few queries whilst Probes is more advanced and uses a few queries per probe. Cannot be changed at runtime after Start.
        /// </remarks>
        public FloatingObjectModel Model { get => _Model; set => _Model = value; }

        /// <summary>
        /// Length dimension of boat.
        /// </summary>
        /// <remarks>
        /// Only used if Use Boat Length is enabled.
        /// </remarks>
        public float ObjectLength { get => _ObjectLength; set => _ObjectLength = value; }

        /// <summary>
        /// Width of object for physics purposes.
        /// </summary>
        /// <remarks>
        /// The larger this value, the more filtered/smooth the wave response will be. If larger wavelengths cannot be filtered, increase the LOD Levels
        /// </remarks>
        public float ObjectWidth { get => _ObjectWidth; set => _ObjectWidth = value; }

        /// <summary>
        /// Query points for buoyancy.
        /// </summary>
        /// <remarks>
        /// Only applicable to Probes model.
        /// </remarks>
        public FloatingObjectProbe[] Probes { get => _Probes; set => _Probes = value; }

        /// <summary>
        /// The rigid body to affect.
        /// </summary>
        /// <remarks>
        /// It will automatically get the sibling rigid body if not set.
        /// </remarks>
        public UnityEngine.Rigidbody RigidBody { get => _RigidBody; set => _RigidBody = value; }

        /// <summary>
        /// Computes a separate normal based on boat length to get more accurate orientations.
        /// </summary>
        /// <remarks>
        /// Requires the cost of an extra collision sample.
        /// </remarks>
        public bool UseObjectLength { get => _UseObjectLength; set => _UseObjectLength = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class FoamLod
    {
        /// <summary>
        /// Prewarms the simulation on load and teleports.
        /// </summary>
        /// <remarks>
        /// Results are only an approximation.
        /// </remarks>
        public bool Prewarm { get => _Prewarm; set => _Prewarm = value; }

        /// <summary>
        /// Settings for fine tuning this simulation.
        /// </summary>
        public FoamLodSettings Settings { get => GetSettings(); set => _Settings = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class FoamLodSettings
    {
        /// <summary>
        /// The minimum LOD  to sample waves from.
        /// </summary>
        /// <remarks>
        /// Zero means all waves and increasing will exclude lower wavelengths which can help with too much foam near the camera.
        /// </remarks>
        public int FilterWaves { get => _FilterWaves; set => _FilterWaves = value; }

        /// <summary>
        /// How quickly foam dissipates.
        /// </summary>
        /// <remarks>
        /// Low values mean foam remains on surface for longer. This setting should be balanced with the generation *strength* parameters below.
        /// </remarks>
        public float FoamFadeRate { get => _FoamFadeRate; set => _FoamFadeRate = value; }

        /// <summary>
        /// Foam will not exceed this value in the simulation which can be used to prevent foam from accumulating too much.
        /// </summary>
        public float Maximum { get => _Maximum; set => _Maximum = value; }

        /// <summary>
        /// Foam will be generated in water shallower than this depth.
        /// </summary>
        /// <remarks>
        /// Controls how wide the band of foam at the shoreline will be. Note that this is not a distance to shoreline, but a threshold on water depth, so the width of the foam band can vary based on terrain slope. To address this limitation we allow foam to be manually added from geometry or from a texture, see the next section.
        /// </remarks>
        public float ShorelineFoamMaximumDepth { get => _ShorelineFoamMaximumDepth; set => _ShorelineFoamMaximumDepth = value; }

        /// <summary>
        /// Primes foam when terrain height is this value above water.
        /// </summary>
        /// <remarks>
        /// This ignores other foam settings and writes a constant foam value.
        /// </remarks>
        public float ShorelineFoamPriming { get => _ShorelineFoamPriming; set => _ShorelineFoamPriming = value; }

        /// <summary>
        /// Scales intensity of foam generated in shallow water.
        /// </summary>
        /// <remarks>
        /// This setting should be balanced with the Foam Fade Rate setting.
        /// </remarks>
        public float ShorelineFoamStrength { get => _ShorelineFoamStrength; set => _ShorelineFoamStrength = value; }

        /// <summary>
        /// How much of the waves generate foam.
        /// </summary>
        /// <remarks>
        /// Higher values will lower the threshold for foam generation, giving a larger area.
        /// </remarks>
        public float WaveFoamCoverage { get => _WaveFoamCoverage; set => _WaveFoamCoverage = value; }

        /// <summary>
        /// Scales intensity of foam generated from waves.
        /// </summary>
        /// <remarks>
        /// This setting should be balanced with the Foam Fade Rate setting.
        /// </remarks>
        public float WaveFoamStrength { get => _WaveFoamStrength; set => _WaveFoamStrength = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class GeometryLodInputData
    {
        /// <summary>
        /// Geometry to render into the simulation.
        /// </summary>
        public UnityEngine.Mesh Geometry { get => _Geometry; set => SetGeometry(_Geometry, _Geometry = value); }
    }
}

namespace WaveHarmonic.Crest
{
    partial class LevelLodInput
    {
        /// <summary>
        /// The minimum and maximum height value to report for water chunk culling.
        /// </summary>
        public UnityEngine.Vector2 HeightRange { get => _HeightRange; set => _HeightRange = value; }

        /// <summary>
        /// Whether to use the manual "Height Range" for water chunk culling.
        /// </summary>
        /// <remarks>
        /// Mandatory for non mesh inputs like "Texture".
        /// </remarks>
        public bool OverrideHeight { get => _OverrideHeight; set => _OverrideHeight = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class Lod
    {
        /// <summary>
        /// Whether the simulation is enabled.
        /// </summary>
        public bool Enabled { get => GetEnabled(); set => SetEnabled(_Enabled, _Enabled = value); }

        /// <summary>
        /// Whether to override the resolution.
        /// </summary>
        /// <remarks>
        /// If not enabled, then the simulation will use the resolution defined on the Water Renderer.
        /// </remarks>
        public bool OverrideResolution { get => _OverrideResolution; set => SetDirty(_OverrideResolution, _OverrideResolution = value); }

        /// <summary>
        /// The resolution of the simulation data.
        /// </summary>
        /// <remarks>
        /// Set higher for sharper results at the cost of higher memory usage.
        /// </remarks>
        public int Resolution { get => GetResolution(); set => SetDirty(_Resolution, _Resolution = value); }

        /// <summary>
        /// The render texture format used for this simulation data.
        /// </summary>
        /// <remarks>
        /// It will be overriden if the format is incompatible with the platform.
        /// </remarks>
        public UnityEngine.Experimental.Rendering.GraphicsFormat TextureFormat { get => _TextureFormat; set => SetDirty(_TextureFormat, _TextureFormat = value); }

        /// <summary>
        /// Chooses a texture format based on a preset value.
        /// </summary>
        public LodTextureFormatMode TextureFormatMode { get => _TextureFormatMode; set => SetDirty(_TextureFormatMode, _TextureFormatMode = value); }
    }
}

namespace WaveHarmonic.Crest
{
    partial class LodInput
    {
        /// <summary>
        /// How this input blends into existing data.
        /// </summary>
        /// <remarks>
        /// Similar to blend operations in shaders. For inputs which have materials, use the blend functionality on the shader/material.
        /// </remarks>
        public LodInputBlend Blend { get => _Blend; set => _Blend = value; }

        /// <summary>
        /// The width of the feathering to soften the edges to blend inputs.
        /// </summary>
        /// <remarks>
        /// Inputs that do not support feathering will have this field disabled or hidden in UI.
        /// </remarks>
        public float FeatherWidth { get => _FeatherWidth; set => _FeatherWidth = value; }

        /// <summary>
        /// How this input responds to horizontal displacement.
        /// </summary>
        /// <remarks>
        /// If false, data will not move horizontally with the waves. Has a small performance overhead when disabled. Only suitable for inputs of small size.
        /// </remarks>
        public bool FollowHorizontalWaveMotion { get => _FollowHorizontalWaveMotion; set => _FollowHorizontalWaveMotion = value; }

        /// <summary>
        /// The mode for this input.
        /// </summary>
        /// <remarks>
        /// See the manual for more details about input modes. Use AddComponent(LodInputMode) to set the mode via scripting. The mode cannot be changed after creation.
        /// </remarks>
        public LodInputMode Mode => _Mode;

        /// <summary>
        /// The order this input will render.
        /// </summary>
        /// <remarks>
        /// Order is Queue plus SiblingIndex
        /// </remarks>
        public int Queue { get => _Queue; set => SetQueue(_Queue, _Queue = value); }

        /// <summary>
        /// Scales the input.
        /// </summary>
        public float Weight { get => _Weight; set => _Weight = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class Meniscus
    {
        /// <summary>
        /// Whether the meniscus is enabled.
        /// </summary>
        public bool Enabled { get => GetEnabled(); set => SetEnabled(_Enabled, _Enabled = value); }

        /// <summary>
        /// Any camera with this layer in its culling mask will render the meniscus.
        /// </summary>
        public int Layer { get => _Layer; set => _Layer = value; }

        /// <summary>
        /// The meniscus material.
        /// </summary>
        public UnityEngine.Material Material { get => _Material; set => SetMaterial(_Material, _Material = value); }
    }
}

namespace WaveHarmonic.Crest
{
    partial class PersistentLod
    {
        /// <summary>
        /// Frequency to run the simulation, in updates per second.
        /// </summary>
        /// <remarks>
        /// Lower frequencies are more efficient but may lead to visible jitter or slowness.
        /// </remarks>
        public int SimulationFrequency { get => _SimulationFrequency; set => _SimulationFrequency = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class QualitySettingsOverride
    {
        /// <summary>
        /// Overrides the LOD bias for meshes.
        /// </summary>
        /// <remarks>
        /// Highest quality is infinity.
        /// </remarks>
        public float LodBias { get => _LodBias; set => _LodBias = value; }

        /// <summary>
        /// Overrides the maximum LOD level.
        /// </summary>
        /// <remarks>
        /// Highest quality is zero.
        /// </remarks>
        public int MaximumLodLevel { get => _MaximumLodLevel; set => _MaximumLodLevel = value; }

        /// <summary>
        /// Whether to override the LOD bias.
        /// </summary>
        public bool OverrideLodBias { get => _OverrideLodBias; set => _OverrideLodBias = value; }

        /// <summary>
        /// Whether to override the maximum LOD level.
        /// </summary>
        public bool OverrideMaximumLodLevel { get => _OverrideMaximumLodLevel; set => _OverrideMaximumLodLevel = value; }

        /// <summary>
        /// Whether to override the terrain pixel error.
        /// </summary>
        public bool OverrideTerrainPixelError { get => _OverrideTerrainPixelError; set => _OverrideTerrainPixelError = value; }

        /// <summary>
        /// Overrides the pixel error value for terrains.
        /// </summary>
        /// <remarks>
        /// Highest quality is zero.
        /// </remarks>
        public float TerrainPixelError { get => _TerrainPixelError; set => _TerrainPixelError = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class QueryEvents
    {
        /// <summary>
        /// Sends the distance from the water's edge.
        /// </summary>
        public System.Action<float> DistanceFromEdge { get; set; }

        /// <summary>
        /// Apply a curve to the distance.
        /// </summary>
        /// <remarks>
        /// Values towards "one" means closer to the water's edge.
        /// </remarks>
        public UnityEngine.AnimationCurve DistanceFromEdgeCurve { get => _DistanceFromEdgeCurve; set => _DistanceFromEdgeCurve = value; }

        /// <summary>
        /// The maximum distance.
        /// </summary>
        /// <remarks>
        /// Always use a real distance in real units (ie not normalized).
        /// </remarks>
        public float DistanceFromEdgeMaximum { get => _DistanceFromEdgeMaximum; set => _DistanceFromEdgeMaximum = value; }

        /// <summary>
        /// Whether to keep the sign of the value (ie positive/negative).
        /// </summary>
        /// <remarks>
        /// A positive value means the query point is over water, while a negative means it is over land.
        /// </remarks>
        public bool DistanceFromEdgeSigned { get => _DistanceFromEdgeSigned; set => _DistanceFromEdgeSigned = value; }

        /// <summary>
        /// Apply a curve to the distance.
        /// </summary>
        /// <remarks>
        /// Normalizes and inverts the distance to be between zero and one, then applies a curve.
        /// </remarks>
        public bool DistanceFromEdgeUseCurve { get => _DistanceFromEdgeUseCurve; set => _DistanceFromEdgeUseCurve = value; }

        /// <summary>
        /// Sends the distance from the water surface.
        /// </summary>
        public System.Action<float> DistanceFromSurface { get; set; }

        /// <summary>
        /// Apply a curve to the distance.
        /// </summary>
        /// <remarks>
        /// Values towards "one" means closer to the water surface.
        /// </remarks>
        public UnityEngine.AnimationCurve DistanceFromSurfaceCurve { get => _DistanceFromSurfaceCurve; set => _DistanceFromSurfaceCurve = value; }

        /// <summary>
        /// The maximum distance.
        /// </summary>
        /// <remarks>
        /// Always use a real distance in real units (ie not normalized).
        /// </remarks>
        public float DistanceFromSurfaceMaximum { get => _DistanceFromSurfaceMaximum; set => _DistanceFromSurfaceMaximum = value; }

        /// <summary>
        /// Whether to keep the sign of the value (ie positive/negative).
        /// </summary>
        /// <remarks>
        /// A positive value means the query point is above the surface, while a negative means it below the surface.
        /// </remarks>
        public bool DistanceFromSurfaceSigned { get => _DistanceFromSurfaceSigned; set => _DistanceFromSurfaceSigned = value; }

        /// <summary>
        /// Whether to apply a curve to the distance.
        /// </summary>
        /// <remarks>
        /// Normalizes and inverts the distance to be between zero and one, then applies a curve.
        /// </remarks>
        public bool DistanceFromSurfaceUseCurve { get => _DistanceFromSurfaceUseCurve; set => _DistanceFromSurfaceUseCurve = value; }

        /// <summary>
        /// Which water collision layer to target.
        /// </summary>
        public CollisionLayer Layer { get => _Layer; set => _Layer = value; }

        /// <summary>
        /// The minimum wavelength for queries.
        /// </summary>
        /// <remarks>
        /// The higher the value, the more smaller waves will be ignored when sampling the water surface.
        /// </remarks>
        public float MinimumWavelength { get => _MinimumWavelength; set => _MinimumWavelength = value; }

        /// <summary>
        /// Triggers when game object goes above water surface.
        /// </summary>
        /// <remarks>
        /// Triggers once per state change.
        /// </remarks>
        public System.Action OnAboveWater { get; set; }

        /// <summary>
        /// Triggers when game object goes below water surface.
        /// </summary>
        /// <remarks>
        /// Triggers once per state change.
        /// </remarks>
        public System.Action OnBelowWater { get; set; }

        /// <summary>
        /// What transform should the queries be based on.
        /// </summary>
        /// <remarks>
        /// "Viewer" will reuse queries already performed by the Water Renderer
        /// </remarks>
        public QuerySource Source { get => _Source; set => _Source = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class RendererLodInputData
    {
        /// <summary>
        /// Check that the shader applied to this object matches the input type.
        /// </summary>
        /// <remarks>
        /// For example, an Animated Waves input object has an Animated Waves input shader.
        /// </remarks>
        public bool CheckShaderName { get => _CheckShaderName; set => _CheckShaderName = value; }

        /// <summary>
        /// Check that the shader applied to this object has only a single pass, as only the first pass is executed for most inputs.
        /// </summary>
        public bool CheckShaderPasses { get => _CheckShaderPasses; set => _CheckShaderPasses = value; }

        /// <summary>
        /// Forces the renderer to only render into the LOD data, and not to render in the scene as it normally would.
        /// </summary>
        public bool DisableRenderer { get => _DisableRenderer; set => SetDisableRenderer(_DisableRenderer, _DisableRenderer = value); }

        /// <summary>
        /// Whether to set the shader pass manually.
        /// </summary>
        public bool OverrideShaderPass { get => _OverrideShaderPass; set => _OverrideShaderPass = value; }

        /// <summary>
        /// The renderer to use for this input.
        /// </summary>
        /// <remarks>
        /// Can be anything that inherits from <i>Renderer</i> like <i>MeshRenderer</i>, <i>TrailRenderer</i> etc.
        /// </remarks>
        public UnityEngine.Renderer Renderer { get => _Renderer; set => SetRenderer(_Renderer, _Renderer = value); }

        /// <summary>
        /// The shader pass to execute.
        /// </summary>
        /// <remarks>
        /// Set to -1 to execute all passes.
        /// </remarks>
        public int ShaderPassIndex { get => _ShaderPassIndex; set => _ShaderPassIndex = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class ShadowLod
    {
        /// <summary>
        /// Current frame weight for accumulation over frames for hard shadows.
        /// </summary>
        /// <remarks>
        /// Roughly means 'responsiveness' for hard shadows.
        /// </remarks>
        public float CurrentFrameWeightHard { get => _CurrentFrameWeightHard; set => _CurrentFrameWeightHard = value; }

        /// <summary>
        /// Current frame weight for accumulation over frames for soft shadows.
        /// </summary>
        /// <remarks>
        /// Roughly means 'responsiveness' for soft shadows.
        /// </remarks>
        public float CurrentFrameWeightSoft { get => _CurrentFrameWeightSoft; set => _CurrentFrameWeightSoft = value; }

        /// <summary>
        /// Jitter diameter for hard shadows, controls softness of this shadowing component.
        /// </summary>
        public float JitterDiameterHard { get => _JitterDiameterHard; set => _JitterDiameterHard = value; }

        /// <summary>
        /// Jitter diameter for soft shadows, controls softness of this shadowing component.
        /// </summary>
        public float JitterDiameterSoft { get => _JitterDiameterSoft; set => _JitterDiameterSoft = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class ShapeFFT
    {
        /// <summary>
        /// Maximum amount a point on the surface will be displaced horizontally by waves from its rest position.
        /// </summary>
        /// <remarks>
        /// Increase this if gaps appear at sides of screen.
        /// </remarks>
        public float MaximumHorizontalDisplacement { get => _MaximumHorizontalDisplacement; set => _MaximumHorizontalDisplacement = value; }

        /// <summary>
        /// Maximum amount the surface will be displaced vertically from sea level.
        /// </summary>
        /// <remarks>
        /// Increase this if gaps appear at bottom of screen.
        /// </remarks>
        public float MaximumVerticalDisplacement { get => _MaximumVerticalDisplacement; set => _MaximumVerticalDisplacement = value; }

        /// <summary>
        /// Whether to use the wind turbulence on this component rather than the global wind turbulence.
        /// </summary>
        /// <remarks>
        /// Global wind turbulence comes from the Water Renderer component.
        /// </remarks>
        public bool OverrideGlobalWindTurbulence { get => _OverrideGlobalWindTurbulence; set => _OverrideGlobalWindTurbulence = value; }

        /// <summary>
        /// FFT waves will loop with a period of this many seconds.
        /// </summary>
        public float TimeLoopLength { get => _TimeLoopLength; set => _TimeLoopLength = value; }

        /// <summary>
        /// How aligned the waves are with wind.
        /// </summary>
        public float WindAlignment { get => _WindAlignment; set => _WindAlignment = value; }

        /// <summary>
        /// How turbulent/chaotic the waves are.
        /// </summary>
        public float WindTurbulence { get => GetWindTurbulence(); set => _WindTurbulence = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class ShapeGerstner
    {
        /// <summary>
        /// How many wave components to generate in each octave.
        /// </summary>
        public int ComponentsPerOctave { get => _ComponentsPerOctave; set => _ComponentsPerOctave = value; }

        /// <summary>
        /// Prevent data arrays from being written to so one can provide their own.
        /// </summary>
        public bool ManualGeneration { get => _ManualGeneration; set => _ManualGeneration = value; }

        /// <summary>
        /// Change to get a different set of waves.
        /// </summary>
        public int RandomSeed { get => _RandomSeed; set => _RandomSeed = value; }

        /// <summary>
        /// The weight of the opposing, second pair of Gerstner waves.
        /// </summary>
        /// <remarks>
        /// Each Gerstner wave is actually a pair of waves travelling in opposite directions (similar to FFT). This weight is applied to the wave travelling in against-wind direction. Set to zero to obtain simple single waves which are useful for shorelines waves.
        /// </remarks>
        public float ReverseWaveWeight { get => GetReverseWaveWeight(); set => _ReverseWaveWeight = value; }

        /// <summary>
        /// Use a swell spectrum as the default.
        /// </summary>
        /// <remarks>
        /// Uses a swell spectrum as default (when none is assigned), and disabled reverse waves.
        /// </remarks>
        public bool Swell { get => _Swell; set => _Swell = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class ShapeWaves
    {
        /// <summary>
        /// Whether to evaluate the spectrum every frame.
        /// </summary>
        /// <remarks>
        /// When false, the wave spectrum is evaluated once on startup in editor play mode and standalone builds, rather than every frame. This is less flexible, but it reduces the performance cost significantly.
        /// </remarks>
        public bool EvaluateSpectrumAtRunTimeEveryFrame { get => _EvaluateSpectrumAtRunTimeEveryFrame; set => _EvaluateSpectrumAtRunTimeEveryFrame = value; }

        /// <summary>
        /// Whether to use the wind direction on this component rather than the global wind direction.
        /// </summary>
        /// <remarks>
        /// Global wind direction comes from the Water Renderer component.
        /// </remarks>
        public bool OverrideGlobalWindDirection { get => _OverrideGlobalWindDirection; set => _OverrideGlobalWindDirection = value; }

        /// <summary>
        /// Whether to use the wind speed on this component rather than the global wind speed.
        /// </summary>
        /// <remarks>
        /// Global wind speed comes from the Water Renderer component.
        /// </remarks>
        public bool OverrideGlobalWindSpeed { get => _OverrideGlobalWindSpeed; set => _OverrideGlobalWindSpeed = value; }

        /// <summary>
        /// Resolution to use for wave generation buffers.
        /// </summary>
        /// <remarks>
        /// Low resolutions are more efficient but can result in noticeable patterns in the shape.
        /// </remarks>
        public int Resolution { get => _Resolution; set => _Resolution = value; }

        /// <summary>
        /// How much these waves respect the shallow water attenuation.
        /// </summary>
        /// <remarks>
        /// Attenuation is defined on the Animated Waves. Set to zero to ignore attenuation.
        /// </remarks>
        public float RespectShallowWaterAttenuation { get => _RespectShallowWaterAttenuation; set => _RespectShallowWaterAttenuation = value; }

        /// <summary>
        /// The spectrum that defines the water surface shape.
        /// </summary>
        public WaveSpectrum Spectrum { get => _Spectrum; set => _Spectrum = value; }

        /// <summary>
        /// Primary wave direction heading (degrees).
        /// </summary>
        /// <remarks>
        /// This is the angle from x axis in degrees that the waves are oriented towards. If a spline is being used to place the waves, this angle is relative to the spline.
        /// </remarks>
        public float WaveDirectionHeadingAngle { get => GetWaveDirectionHeadingAngle(); set => _WaveDirectionHeadingAngle = value; }

        /// <summary>
        /// Wind speed in km/h. Controls wave conditions.
        /// </summary>
        public float WindSpeed { get => _WindSpeed; set => _WindSpeed = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class SphereWaterInteraction
    {
        /// <summary>
        /// Whether to improve visibility in larger LODs.
        /// </summary>
        /// <remarks>
        /// If the dynamic waves are not visible far enough in the distance from the camera, this can be used to boost the output.
        /// </remarks>
        public bool BoostLargeWaves { get => _BoostLargeWaves; set => _BoostLargeWaves = value; }

        /// <summary>
        /// How much to correct the position for horizontal wave displacement.
        /// </summary>
        /// <remarks>
        /// If set to 0, the input will always be applied at a fixed position before any horizontal displacement from waves. If waves are large then their displacement may cause the interactive waves to drift away from the object. This parameter can be increased to compensate for this displacement and combat this issue. However increasing too far can cause a feedback loop which causes strong 'ring' artifacts to appear in the dynamic waves. This parameter can be tweaked to balance this two effects.
        /// </remarks>
        public float CompensateForWaveMotion { get => _CompensateForWaveMotion; set => _CompensateForWaveMotion = value; }

        /// <summary>
        /// Model parameter that can be used to modify the shape of the interaction.
        /// </summary>
        /// <remarks>
        /// Internally the interaction is modelled by a pair of nested spheres. The forces from the two spheres combine to create the final effect. This parameter scales the effect of the inner sphere and can be tweaked to adjust the shape of the result.
        /// </remarks>
        public float InnerSphereMultiplier { get => _InnerSphereMultiplier; set => _InnerSphereMultiplier = value; }

        /// <summary>
        /// Model parameter that can be used to modify the shape of the interaction.
        /// </summary>
        /// <remarks>
        /// This parameter controls the size of the inner sphere and can be tweaked to give further control over the result.
        /// </remarks>
        public float InnerSphereOffset { get => _InnerSphereOffset; set => _InnerSphereOffset = value; }

        /// <summary>
        /// Maximum speed clamp (km/h).
        /// </summary>
        /// <remarks>
        /// Useful for controlling/limiting wake.
        /// </remarks>
        public float MaximumSpeed { get => _MaximumSpeed; set => _MaximumSpeed = value; }

        /// <summary>
        /// Radius of the sphere that is modelled from which the interaction forces are calculated.
        /// </summary>
        public float Radius { get => _Radius; set => _Radius = value; }

        /// <summary>
        /// Teleport speed (km/h).
        /// </summary>
        /// <remarks>
        /// If the calculated speed is larger than this amount, the object is deemed to have teleported and the computed velocity is discarded.
        /// </remarks>
        public float TeleportSpeed { get => _TeleportSpeed; set => _TeleportSpeed = value; }

        /// <summary>
        /// Offset in direction of motion to help ripples appear in front of sphere.
        /// </summary>
        /// <remarks>
        /// There is some latency between applying a force to the wave simualtion and the resulting waves appearing. Applying this offset can help to ensure the waves do not lag behind the sphere.
        /// </remarks>
        public float VelocityOffset { get => _VelocityOffset; set => _VelocityOffset = value; }

        /// <summary>
        /// Outputs a warning to the console on speed clamp.
        /// </summary>
        public bool WarnOnSpeedClamp { get => _WarnOnSpeedClamp; set => _WarnOnSpeedClamp = value; }

        /// <summary>
        /// Outputs a warning to the console on teleport.
        /// </summary>
        public bool WarnOnTeleport { get => _WarnOnTeleport; set => _WarnOnTeleport = value; }

        /// <summary>
        /// Intensity of the forces.
        /// </summary>
        /// <remarks>
        /// Can be set negative to invert.
        /// </remarks>
        public float Weight { get => _Weight; set => _Weight = value; }

        /// <summary>
        /// Intensity of the forces from vertical motion of the sphere.
        /// </summary>
        /// <remarks>
        /// Scales ripples generated from a sphere moving up or down.
        /// </remarks>
        public float WeightVerticalMultiplier { get => _WeightVerticalMultiplier; set => _WeightVerticalMultiplier = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class SurfaceRenderer
    {
        /// <summary>
        /// Whether to allow sorting using the render queue.
        /// </summary>
        /// <remarks>
        /// If you need to change the minor part of the render queue (eg +100), then enable this option. As a side effect, it will also disable the front-to-back rendering optimization for Crest. This option does not affect changing the major part of the render queue (eg AlphaTest, Transparent), as that is always allowed.
        /// </remarks>
        public bool AllowRenderQueueSorting { get => _AllowRenderQueueSorting; set => _AllowRenderQueueSorting = value; }

        /// <summary>
        /// Have the water surface cast shadows for albedo (both foam and custom).
        /// </summary>
        public bool CastShadows { get => GetCastShadows(); set => _CastShadows = value; }

        /// <summary>
        /// Whether the underwater effect is enabled.
        /// </summary>
        /// <remarks>
        /// Allocates/releases resources if state has changed.
        /// </remarks>
        public bool Enabled { get => GetEnabled(); set => SetEnabled(_Enabled, _Enabled = value); }

        /// <summary>
        /// The water chunk renderers will have this layer.
        /// </summary>
        public int Layer { get => _Layer; set => _Layer = value; }

        /// <summary>
        /// Material to use for the water surface.
        /// </summary>
        public UnityEngine.Material Material { get => _Material; set => _Material = value; }

        /// <summary>
        /// How many frames to distribute the chunk bounds calculation.
        /// </summary>
        /// <remarks>
        /// The chunk bounds are calculated per frame to ensure culling is correct when using inputs that affect displacement. Some performance can be saved by distributing the load over several frames. The higher the frames, the longer it will take - lowest being instant.
        /// </remarks>
        public int TimeSliceBoundsUpdateFrameCount { get => _TimeSliceBoundsUpdateFrameCount; set => _TimeSliceBoundsUpdateFrameCount = value; }

        /// <summary>
        /// Underwater will copy from this material if set.
        /// </summary>
        /// <remarks>
        /// Useful for overriding properties for the underwater effect. To see what properties can be overriden, see the disabled properties on the underwater material. This does not affect the surface.
        /// </remarks>
        public UnityEngine.Material VolumeMaterial { get => _VolumeMaterial; set => _VolumeMaterial = value; }

        /// <summary>
        /// Whether 'Water Body' components will cull the water tiles.
        /// </summary>
        /// <remarks>
        /// Disable if you want to use the 'Material Override' feature and still have an ocean.
        /// </remarks>
        public bool WaterBodyCulling { get => _WaterBodyCulling; set => _WaterBodyCulling = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class TextureLodInputData
    {
        /// <summary>
        /// Multiplies the texture sample.
        /// </summary>
        /// <remarks>
        /// This is useful for normalized textures. The four components map to the four color/alpha components of the texture (if they exist).
        /// </remarks>
        public UnityEngine.Vector4 Multiplier { get => _Multiplier; set => _Multiplier = value; }

        /// <summary>
        /// Texture to render into the simulation.
        /// </summary>
        public UnityEngine.Texture Texture { get => _Texture; set => _Texture = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class UnderwaterRenderer
    {
        /// <summary>
        /// Whether to execute for all cameras.
        /// </summary>
        /// <remarks>
        /// If disabled, then additionally ignore any camera that is not the view camera or our reflection camera. It will require managing culling masks of all cameras.
        /// </remarks>
        public bool AllCameras { get => _AllCameras; set => _AllCameras = value; }

        /// <summary>
        /// Copying parameters each frame ensures underwater appearance stays consistent with the water surface.
        /// </summary>
        /// <remarks>
        /// Has a small overhead so should be disabled if not needed.
        /// </remarks>
        public bool CopyWaterMaterialParametersEachFrame { get => _CopyWaterMaterialParametersEachFrame; set => _CopyWaterMaterialParametersEachFrame = value; }

        /// <summary>
        /// Proportion of visibility below which the water surface will be culled when underwater.
        /// </summary>
        /// <remarks>
        /// The larger the number, the closer to the camera the water tiles will be culled.
        /// </remarks>
        public float CullLimit { get => _CullLimit; set => _CullLimit = value; }

        /// <summary>
        /// Whether the underwater effect is enabled.
        /// </summary>
        /// <remarks>
        /// Allocates/releases resources if state has changed.
        /// </remarks>
        public bool Enabled { get => _Enabled; set => SetEnabled(_Enabled, _Enabled = value); }

        /// <summary>
        /// Provides out-scattering based on the camera's underwater depth.
        /// </summary>
        /// <remarks>
        /// It scales down environmental lighting (sun, reflections, ambient etc) with the underwater depth. This works with vanilla lighting, but uncommon or custom lighting will require a custom solution (use this for reference)
        /// </remarks>
        public bool AffectsEnvironmentalLighting { get => _EnvironmentalLightingEnable; set => SetAffectsEnvironmentalLighting(_EnvironmentalLightingEnable, _EnvironmentalLightingEnable = value); }

        /// <summary>
        /// How much this effect applies.
        /// </summary>
        /// <remarks>
        /// Values less than 1 attenuate light less underwater. Value of 1 is physically based.
        /// </remarks>
        public float EnvironmentalLightingWeight { get => _EnvironmentalLightingWeight; set => _EnvironmentalLightingWeight = value; }

        /// <summary>
        /// Adjusts the far plane for horizon line calculation. Helps with horizon line issue.
        /// </summary>
        public float FarPlaneMultiplier { get => _FarPlaneMultiplier; set => _FarPlaneMultiplier = value; }

        /// <summary>
        /// Any camera or probe with this layer in its culling mask will render underwater.
        /// </summary>
        public int Layer { get => _Layer; set => _Layer = value; }

        /// <summary>
        /// The underwater material. The water surface material is copied into this material.
        /// </summary>
        public UnityEngine.Material Material { get => _Material; set => _Material = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class WaterBody
    {
        /// <summary>
        /// Overrides the property on the Water Renderer with the same name when the camera is inside the bounds.
        /// </summary>
        public UnityEngine.Material BelowSurfaceMaterial { get => _BelowSurfaceMaterial; set => _BelowSurfaceMaterial = value; }

        /// <summary>
        /// Makes sure this water body is not clipped.
        /// </summary>
        /// <remarks>
        /// If clipping is enabled and set to clip everywhere by default, this option will register this water body to ensure its area does not get clipped.
        /// </remarks>
        public bool Clipped { get => _Clip; set => _Clip = value; }

        /// <summary>
        /// Water chunks that overlap this waterbody area will be assigned this material.
        /// </summary>
        /// <remarks>
        /// This is useful for varying water appearance across different water bodies. If no override material is specified, the default material assigned to the WaterRenderer component will be used.
        /// </remarks>
        public UnityEngine.Material AboveSurfaceMaterial { get => _Material; set => _Material = value; }

        /// <summary>
        /// Overrides the Water Renderer's volume material when the camera is inside the bounds.
        /// </summary>
        public UnityEngine.Material VolumeMaterial { get => _VolumeMaterial; set => _VolumeMaterial = value; }
    }
}

namespace WaveHarmonic.Crest.Watercraft
{
    partial class Controller
    {
        /// <summary>
        /// Applies a curve to buoyancy changes.
        /// </summary>
        public UnityEngine.AnimationCurve BuoyancyCurveFactor { get => _BuoyancyCurveFactor; set => _BuoyancyCurveFactor = value; }

        /// <summary>
        /// The accompanied control script to take input from.
        /// </summary>
        public Control Control { get => _Control; set => _Control = value; }

        /// <summary>
        /// The accompanied buoyancy script.
        /// </summary>
        public WaveHarmonic.Crest.FloatingObject FloatingObject { get => _FloatingObject; set => _FloatingObject = value; }

        /// <summary>
        /// Vertical offset from the center of mass for where move force should be applied.
        /// </summary>
        public float ForceHeightOffset { get => _ForceHeightOffset; set => _ForceHeightOffset = value; }

        /// <summary>
        /// How quickly the watercraft turns from steering.
        /// </summary>
        public float SteerPower { get => _SteerPower; set => _SteerPower = value; }

        /// <summary>
        /// How quickly the watercraft moves from thrust.
        /// </summary>
        public float ThrustPower { get => _ThrustPower; set => _ThrustPower = value; }

        /// <summary>
        /// Rolls the watercraft when turning.
        /// </summary>
        public float TurningHeel { get => _TurningHeel; set => _TurningHeel = value; }
    }
}

namespace WaveHarmonic.Crest.Watercraft
{
    partial class FixedControl
    {
        /// <summary>
        /// Constantly move.
        /// </summary>
        public float Move { get => _Move; set => _Move = value; }

        /// <summary>
        /// Constantly turn.
        /// </summary>
        public float Turn { get => _Turn; set => _Turn = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class WaterReflections
    {
        /// <summary>
        /// Whether to allow MSAA.
        /// </summary>
        public bool AllowMSAA { get => _AllowMSAA; set => _AllowMSAA = value; }

        /// <summary>
        /// The near clip plane clips any geometry before it, removing it from reflections.
        /// </summary>
        /// <remarks>
        /// Can be used to reduce reflection leaks and support varied water level.
        /// </remarks>
        public float ClipPlaneOffset { get => _ClipPlaneOffset; set => _ClipPlaneOffset = value; }

        /// <summary>
        /// Disables occlusion culling.
        /// </summary>
        public bool DisableOcclusionCulling { get => _DisableOcclusionCulling; set => _DisableOcclusionCulling = value; }

        /// <summary>
        /// Disables pixel lights (BIRP only).
        /// </summary>
        public bool DisablePixelLights { get => _DisablePixelLights; set => _DisablePixelLights = value; }

        /// <summary>
        /// Disables shadows.
        /// </summary>
        public bool DisableShadows { get => _DisableShadows; set => _DisableShadows = value; }

        /// <summary>
        /// Whether planar reflections are enabled.
        /// </summary>
        /// <remarks>
        /// Allocates/releases resources if state has changed.
        /// </remarks>
        public bool Enabled { get => _Enabled; set => SetEnabled(_Enabled, _Enabled = value); }

        /// <summary>
        /// Anything beyond the far clip plane is not rendered.
        /// </summary>
        public float FarClipPlane { get => _FarClipPlane; set => _FarClipPlane = value; }

        /// <summary>
        /// Whether to allow HDR.
        /// </summary>
        public bool HDR { get => _HDR; set => _HDR = value; }

        /// <summary>
        /// The layers to rendering into reflections.
        /// </summary>
        public UnityEngine.LayerMask Layers { get => _Layers; set => _Layers = value; }

        /// <summary>
        /// What side of the water surface to render planar reflections for.
        /// </summary>
        public WaterReflectionSide ReflectionSide { get => _Mode; set => _Mode = value; }

        /// <summary>
        /// Planar relfections using an oblique frustum for better performance.
        /// </summary>
        /// <remarks>
        /// This can cause depth issues for TIRs, especially near the surface.
        /// </remarks>
        public bool NonObliqueNearSurface { get => _NonObliqueNearSurface; set => _NonObliqueNearSurface = value; }

        /// <summary>
        /// If within this distance from the surface, disable the oblique matrix.
        /// </summary>
        public float NonObliqueNearSurfaceThreshold { get => _NonObliqueNearSurfaceThreshold; set => _NonObliqueNearSurfaceThreshold = value; }

        /// <summary>
        /// Overrides global quality settings.
        /// </summary>
        public QualitySettingsOverride QualitySettingsOverride { get => _QualitySettingsOverride; set => _QualitySettingsOverride = value; }

        /// <summary>
        /// Whether to render to the viewer camera only.
        /// </summary>
        /// <remarks>
        /// When disabled, reflections will render for all cameras rendering the water layer, which currently this prevents Refresh Rate from working. Enabling will unlock the Refresh Rate heading.
        /// </remarks>
        public bool RenderOnlySingleCamera { get => _RenderOnlySingleCamera; set => _RenderOnlySingleCamera = value; }

        /// <summary>
        /// Resolution of the reflection texture.
        /// </summary>
        public int Resolution { get => _Resolution; set => _Resolution = value; }

        /// <summary>
        /// Whether to render the sky or fallback to default reflections.
        /// </summary>
        /// <remarks>
        /// Not rendering the sky can prevent other custom shaders (like tree leaves) from being in the final output. Enable for best compatibility.
        /// </remarks>
        public bool Sky { get => _Sky; set => _Sky = value; }

        /// <summary>
        /// Whether to allow stencil operations.
        /// </summary>
        public bool Stencil { get => _Stencil; set => _Stencil = value; }

        /// <summary>
        /// An oblique matrix will clip anything below the surface for free.
        /// </summary>
        /// <remarks>
        /// Disable if you have problems with certain effects. Disabling can cause other artifacts like objects below the surface to appear in reflections.
        /// </remarks>
        public bool UseObliqueMatrix { get => _UseObliqueMatrix; set => _UseObliqueMatrix = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class WaterRenderer
    {
        /// <summary>
        /// Absorption information - gives color to water.
        /// </summary>
        public AbsorptionLod AbsorptionLod => _AbsorptionLod;

        /// <summary>
        /// Albedo - a colour layer composited onto the water surface.
        /// </summary>
        public AlbedoLod AlbedoLod => _AlbedoLod;

        /// <summary>
        /// Whether to allow sorting using the render queue.
        /// </summary>
        /// <remarks>
        /// If you need to change the minor part of the render queue (eg +100), then enable this option. As a side effect, it will also disable the front-to-back rendering optimization for Crest. This option does not affect changing the major part of the render queue (eg AlphaTest, Transparent), as that is always allowed.
        /// </remarks>
        [System.Obsolete("This property can now be found on WaterRenderer.Surface")]
        public bool AllowRenderQueueSorting { get => GetAllowRenderQueueSorting(); set => SetAllowRenderQueueSorting(_AllowRenderQueueSorting, _AllowRenderQueueSorting = value); }

        /// <summary>
        /// All waves (including Dynamic Waves) are written to this simulation.
        /// </summary>
        public AnimatedWavesLod AnimatedWavesLod => _AnimatedWavesLod;

        /// <summary>
        /// The camera which drives the water data.
        /// </summary>
        /// <remarks>
        /// Setting this is optional. Defaults to the main camera.
        /// </remarks>
        public UnityEngine.Camera Viewer { get => GetViewer(); set => _Camera = value; }

        /// <summary>
        /// Have the water surface cast shadows for albedo (both foam and custom).
        /// </summary>
        [System.Obsolete("This property can now be found on WaterRenderer.Surface")]
        public bool CastShadows { get => GetCastShadows(); set => SetCastShadows(_CastShadows, _CastShadows = value); }

        /// <summary>
        /// Keep the center of detail from drifting from the viewpoint.
        /// </summary>
        /// <remarks>
        /// Large horizontal displacement can displace the center of detail. This uses queries to keep the center of detail aligned.
        /// </remarks>
        public bool CenterOfDetailDisplacementCorrection { get => _CenterOfDetailDisplacementCorrection; set => _CenterOfDetailDisplacementCorrection = value; }

        /// <summary>
        /// Clip surface information for clipping the water surface.
        /// </summary>
        public ClipLod ClipLod => _ClipLod;

        /// <summary>
        /// Water depth information used for shallow water, shoreline foam, wave attenuation, among others.
        /// </summary>
        public DepthLod DepthLod => _DepthLod;

        /// <summary>
        /// Drops the height for maximum water detail based on waves.
        /// </summary>
        /// <remarks>
        /// This means if there are big waves, max detail level is reached at a lower height, which can help visual range when there are very large waves and camera is at sea level.
        /// </remarks>
        public float DropDetailHeightBasedOnWaves { get => _DropDetailHeightBasedOnWaves; set => _DropDetailHeightBasedOnWaves = value; }

        /// <summary>
        /// Dynamic waves generated from interactions with objects such as boats.
        /// </summary>
        public DynamicWavesLod DynamicWavesLod => _DynamicWavesLod;

        /// <summary>
        /// Applied to the extents' far vertices to make them larger.
        /// </summary>
        /// <remarks>
        /// Increase if the extents do not reach the horizon or you see the underwater effect at the horizon.
        /// </remarks>
        public float ExtentsSizeMultiplier { get => _ExtentsSizeMultiplier; set => _ExtentsSizeMultiplier = value; }

        /// <summary>
        /// Horizontal motion of water body, akin to water currents.
        /// </summary>
        public FlowLod FlowLod => _FlowLod;

        /// <summary>
        /// Simulation of foam created in choppy water and dissipating over time.
        /// </summary>
        public FoamLod FoamLod => _FoamLod;

        /// <summary>
        /// Forces smoothing for scale changes.
        /// </summary>
        /// <remarks>
        /// When water level varies, smoothing scale change can prevent pops when the viewer's height above water sharply changes. Smoothing is disabled when terrain sampling is enabled or the water level simulation is disabled.
        /// </remarks>
        public bool ForceScaleChangeSmoothing { get => _ForceScaleChangeSmoothing; set => _ForceScaleChangeSmoothing = value; }

        /// <summary>
        /// How much of the water shape gets tessellated by geometry.
        /// </summary>
        /// <remarks>
        /// For example, if set to four, every geometry quad will span 4x4 LOD data texels. a value of 2 will generate one vert per 2x2 LOD data texels. A value of 1 means a vert is generated for every LOD data texel. Larger values give lower fidelity surface shape with higher performance.
        /// </remarks>
        public int GeometryDownSampleFactor { get => _GeometryDownSampleFactor; set => _GeometryDownSampleFactor = value; }

        /// <summary>
        /// Multiplier for physics gravity.
        /// </summary>
        public float GravityMultiplier { get => _GravityMultiplier; set => _GravityMultiplier = value; }

        /// <summary>
        /// Gravity for all wave calculations.
        /// </summary>
        public float GravityOverride { get => _GravityOverride; set => _GravityOverride = value; }

        /// <summary>
        /// When in the render pipeline the water is rendered.
        /// </summary>
        /// <remarks>
        /// Default is the old behaviour which is controlled by Unity.
        /// </remarks>
        public WaterInjectionPoint InjectionPoint { get => _InjectionPoint; set => _InjectionPoint = value; }

        /// <summary>
        /// The water chunk renderers will have this layer.
        /// </summary>
        [System.Obsolete("This property can now be found on WaterRenderer.Surface")]
        public int Layer { get => GetLayer(); set => SetLayer(_Layer, _Layer = value); }

        /// <summary>
        /// Varying water level to support water bodies at different heights and rivers to run down slopes.
        /// </summary>
        public LevelLod LevelLod => _LevelLod;

        /// <summary>
        /// Material to use for the water surface.
        /// </summary>
        [System.Obsolete("This property can now be found on WaterRenderer.Surface")]
        public UnityEngine.Material Material { get => GetMaterial(); set => SetMaterial(_Material, _Material = value); }

        /// <summary>
        /// The meniscus module.
        /// </summary>
        public Meniscus Meniscus => _Meniscus;

        /// <summary>
        /// Provide your own gravity value instead of Physics.gravity.
        /// </summary>
        public bool OverrideGravity { get => _OverrideGravity; set => _OverrideGravity = value; }

        /// <summary>
        /// Whether to override the automatic detection of framebuffer HDR rendering (BIRP only).
        /// </summary>
        /// <remarks>
        /// Rendering using HDR formats is optional, but there is no way for us to determine if HDR rendering is enabled in the Graphics Settings. We make an educated based on which platform is the target. If you see rendering issues, try disabling this.
        /// </remarks>
        public bool OverrideRenderHDR { get => _OverrideRenderHDR; set => _OverrideRenderHDR = value; }

        /// <summary>
        /// The portal renderer.
        /// </summary>
        public Portals.PortalRenderer Portals => _Portals;

        /// <summary>
        /// The primary light that affects the water.
        /// </summary>
        /// <remarks>
        /// Setting this is optional. This should be a directional light. Defaults to RenderSettings.sun.
        /// </remarks>
        public UnityEngine.Light PrimaryLight { get => GetPrimaryLight(); set => _PrimaryLight = value; }

        /// <summary>
        /// The reflection renderer.
        /// </summary>
        public WaterReflections Reflections => _Reflections;

        /// <summary>
        /// Force HDR format usage (BIRP only).
        /// </summary>
        /// <remarks>
        /// If enabled, we assume the framebuffer is an HDR format, otherwise an LDR format.
        /// </remarks>
        public bool RenderHDR { get => _RenderHDR; set => _RenderHDR = value; }

        /// <summary>
        /// The resolution of the various water LOD data.
        /// </summary>
        /// <remarks>
        /// This includes mesh density, displacement textures, foam data, dynamic wave simulation, etc. Sets the 'detail' present in the water - larger values give more detail at increased run-time expense. This value can be overriden per LOD in their respective settings except for Animated Waves which is tied to this value.
        /// </remarks>
        public int LodResolution { get => _Resolution; set => _Resolution = value; }

        /// <summary>
        /// Also checks terrain height when determining the scale.
        /// </summary>
        /// <remarks>
        /// The scale is changed based on the viewer's height above the water surface. This can be a problem with varied water level, as the viewer may not be directly over the higher water level leading to a height difference, and thus incorrect scale.
        /// </remarks>
        public bool SampleTerrainHeightForScale { get => _SampleTerrainHeightForScale; set => _SampleTerrainHeightForScale = value; }

        /// <summary>
        /// The scale the water can be (infinity for no maximum).
        /// </summary>
        /// <remarks>
        /// Water is scaled horizontally with viewer height, to keep the meshing suitable for elevated viewpoints. This sets the minimum and maximum the water will be scaled. Low minimum values give lots of detail, but will limit the horizontal extents of the water detail. Increasing the minimum value can be a great performance saving for mobile as it will reduce draw calls.
        /// </remarks>
        public UnityEngine.Vector2 ScaleRange { get => _ScaleRange; set => _ScaleRange = value; }

        /// <summary>
        /// Scattering information - gives color to water.
        /// </summary>
        public ScatteringLod ScatteringLod => _ScatteringLod;

        /// <summary>
        /// Shadow information used for lighting water.
        /// </summary>
        public ShadowLod ShadowLod => _ShadowLod;

        /// <summary>
        /// Number of levels of details (chunks, scales etc) to generate.
        /// </summary>
        /// <remarks>
        /// The horizontal range of the water surface doubles for each added LOD, while GPU processing time increases linearly. The higher the number, the further out detail will be. Furthermore, the higher the count, the more larger wavelengths can be filtering in queries.
        /// </remarks>
        public int LodLevels { get => _Slices; set => _Slices = value; }

        /// <summary>
        /// The water surface renderer.
        /// </summary>
        public SurfaceRenderer Surface => _Surface;

        /// <summary>
        /// The distance threshold for when the viewer has considered to have teleported.
        /// </summary>
        /// <remarks>
        /// This is used to prevent popping, and for prewarming simulations. Threshold is in Unity units.
        /// </remarks>
        public float TeleportThreshold { get => _TeleportThreshold; set => _TeleportThreshold = value; }

        /// <summary>
        /// How many frames to distribute the chunk bounds calculation.
        /// </summary>
        /// <remarks>
        /// The chunk bounds are calculated per frame to ensure culling is correct when using inputs that affect displacement. Some performance can be saved by distributing the load over several frames. The higher the frames, the longer it will take - lowest being instant.
        /// </remarks>
        [System.Obsolete("This property can now be found on WaterRenderer.Surface")]
        public int TimeSliceBoundsUpdateFrameCount { get => GetTimeSliceBoundsUpdateFrameCount(); set => SetTimeSliceBoundsUpdateFrameCount(_TimeSliceBoundsUpdateFrameCount, _TimeSliceBoundsUpdateFrameCount = value); }

        /// <summary>
        /// The underwater renderer.
        /// </summary>
        public UnderwaterRenderer Underwater => _Underwater;

        /// <summary>
        /// The viewpoint which drives the water detail - the center of the LOD system.
        /// </summary>
        /// <remarks>
        /// Setting this is optional. Defaults to the camera.
        /// </remarks>
        public UnityEngine.Transform Viewpoint { get => GetViewpoint(); set => _Viewpoint = value; }

        /// <summary>
        /// Underwater will copy from this material if set.
        /// </summary>
        /// <remarks>
        /// Useful for overriding properties for the underwater effect. To see what properties can be overriden, see the disabled properties on the underwater material. This does not affect the surface.
        /// </remarks>
        [System.Obsolete("This property can now be found on WaterRenderer.Surface")]
        public UnityEngine.Material VolumeMaterial { get => GetVolumeMaterial(); set => SetVolumeMaterial(_VolumeMaterial, _VolumeMaterial = value); }

        /// <summary>
        /// Whether 'Water Body' components will cull the water tiles.
        /// </summary>
        /// <remarks>
        /// Disable if you want to use the 'Material Override' feature and still have an ocean.
        /// </remarks>
        [System.Obsolete("This property can now be found on WaterRenderer.Surface")]
        public bool WaterBodyCulling { get => GetWaterBodyCulling(); set => SetWaterBodyCulling(_WaterBodyCulling, _WaterBodyCulling = value); }

        /// <summary>
        /// Base wind direction in degrees.
        /// </summary>
        /// <remarks>
        /// Controls wave conditions. Can be overridden on Shape* components.
        /// </remarks>
        public float WindDirection { get => GetWindDirection(); set => _WindDirection = value; }

        /// <summary>
        /// Base wind speed in km/h.
        /// </summary>
        /// <remarks>
        /// Controls wave conditions. Can be overridden on Shape* components.
        /// </remarks>
        public float WindSpeed { get => GetWindSpeed(); set => _WindSpeed = value; }

        /// <summary>
        /// Base wind turbulence.
        /// </summary>
        /// <remarks>
        /// Controls wave conditions. Can be overridden on ShapeFFT components.
        /// </remarks>
        public float WindTurbulence { get => GetWindTurbulence(); set => _WindTurbulence = value; }

        /// <summary>
        /// Uses a provided WindZone as the source of global wind.
        /// </summary>
        /// <remarks>
        /// It must be directional. Wind speed units are presumed to be in m/s.
        /// </remarks>
        public UnityEngine.WindZone WindZone { get => _WindZone; set => _WindZone = value; }

        /// <summary>
        /// Whether to enable motion vector support.
        /// </summary>
        public bool WriteMotionVectors { get => GetWriteMotionVectors(); set => _WriteMotionVectors = value; }

        /// <summary>
        /// Whether to write the water surface color to the color/opaque texture.
        /// </summary>
        /// <remarks>
        /// This is likely only beneficial if the water injection point is before transparency, and there are shaders which need it (like refraction).
        /// </remarks>
        public bool WriteToColorTexture { get => GetWriteToColorTexture(); set => _WriteToColorTexture = value; }

        /// <summary>
        /// Whether to write the water surface depth to the depth texture.
        /// </summary>
        /// <remarks>
        /// The water surface writes to the depth buffer, but Unity does not copy it to the depth texture for post-processing effects like Depth of Field (or refraction). This will copy the depth buffer to the depth texture.
        /// </remarks>
        public bool WriteToDepthTexture { get => GetWriteToDepthTexture(); set => _WriteToDepthTexture = value; }
    }
}

namespace WaveHarmonic.Crest
{
    partial class WatertightHull
    {
        /// <summary>
        /// Inverts the effect to remove clipping (ie add water).
        /// </summary>
        public bool Inverted { get => _Inverted; set => _Inverted = value; }

        /// <summary>
        /// The convex hull to keep water out.
        /// </summary>
        public UnityEngine.Mesh Mesh { get => _Mesh; set => _Mesh = value; }

        /// <summary>
        /// Which mode to use.
        /// </summary>
        public WatertightHullMode Mode { get => _Mode; set => SetMode(_Mode, _Mode = value); }

        /// <summary>
        /// Order this input will render.
        /// </summary>
        /// <remarks>
        /// Queue is 'Queue + SiblingIndex'
        /// </remarks>
        public int Queue { get => _Queue; set => SetQueue(_Queue, _Queue = value); }

        /// <summary>
        /// Whether to also to clip the surface when using displacement mode.
        /// </summary>
        /// <remarks>
        /// Displacement mode can have a leaky hull by allowing chop top push waves across the hull boundaries slightly. Clipping the surface will remove these interior leaks.
        /// </remarks>
        public bool UseClipWithDisplacement { get => _UseClipWithDisplacement; set => SetUseClipWithDisplacement(_UseClipWithDisplacement, _UseClipWithDisplacement = value); }
    }
}
